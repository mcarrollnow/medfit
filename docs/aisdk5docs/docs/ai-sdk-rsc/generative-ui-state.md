AI SDK 5 is available now.










Menu










































































































































































































































































































































































































# [Managing Generative UI State](#managing-generative-ui-state)




AI SDK RSC is currently experimental. We recommend using [AI SDK UI](../ai-sdk-ui/overview.html) for production. For guidance on migrating from RSC to UI, see our [migration guide](migrating-to-ui.html).



State is an essential part of any application. State is particularly important in AI applications as it is passed to large language models (LLMs) on each request to ensure they have the necessary context to produce a great generation. Traditional chatbots are text-based and have a structure that mirrors that of any chat application.

For example, in a chatbot, state is an array of `messages` where each `message` has:

- `id`: a unique identifier
- `role`: who sent the message (user/assistant/system/tool)
- `content`: the content of the message

This state can be rendered in the UI and sent to the model without any modifications.

With Generative UI, the model can now return a React component, rather than a plain text message. The client can render that component without issue, but that state can't be sent back to the model because React components aren't serialisable. So, what can you do?

**The solution is to split the state in two, where one (AI State) becomes a proxy for the other (UI State)**.

One way to understand this concept is through a Lego analogy. Imagine a 10,000 piece Lego model that, once built, cannot be easily transported because it is fragile. By taking the model apart, it can be easily transported, and then rebuilt following the steps outlined in the instructions pamphlet. In this way, the instructions pamphlet is a proxy to the physical structure. Similarly, AI State provides a serialisable (JSON) representation of your UI that can be passed back and forth to the model.

## [What is AI and UI State?](#what-is-ai-and-ui-state)

The RSC API simplifies how you manage AI State and UI State, providing a robust way to keep them in sync between your database, server and client.

### [AI State](#ai-state)

AI State refers to the state of your application in a serialisable format that will be used on the server and can be shared with the language model.

For a chat app, the AI State is the conversation history (messages) between the user and the assistant. Components generated by the model would be represented in a JSON format as a tool alongside any necessary props. AI State can also be used to store other values and meta information such as `createdAt` for each message and `chatId` for each conversation. The LLM reads this history so it can generate the next message. This state serves as the source of truth for the current application state.




**Note**: AI state can be accessed/modified from both the server and the client.



### [UI State](#ui-state)

UI State refers to the state of your application that is rendered on the client. It is a fully client-side state (similar to `useState`) that can store anything from Javascript values to React elements. UI state is a list of actual UI elements that are rendered on the client.






## [Using AI / UI State](#using-ai--ui-state)

### [Creating the AI Context](#creating-the-ai-context)


Notably, this means you do not have to pass the message history to the server explicitly for each request. You also can access and update your application state in any child component of the context provider. As you begin building [multistep generative interfaces](multistep-interfaces.html), this will be particularly helpful.

To use `@ai-sdk/rsc` to manage AI and UI State in your application, you can create a React context using [`createAI`](../reference/ai-sdk-rsc/create-ai.html):












``` tsx
// Define the AI state and UI state typesexport type ServerMessage = ;
export type ClientMessage = ;
export const sendMessage = async (input: string): Promise<ClientMessage> => 
```













``` tsx
import  from '@ai-sdk/rsc';import  from './actions';
export type AIState = ServerMessage[];export type UIState = ClientMessage[];
// Create the AI provider with the initial states and allowed actionsexport const AI = createAI<AIState, UIState>(,});
```







In this example, you define types for AI State and UI State, respectively.

Next, wrap your application with your newly created context. With that, you can get and set AI and UI State across your entire application.












``` tsx
import  from 'react';import  from './ai';
export default function RootLayout(: Readonly<>) </body>      </html>    </AI>  );}
```


## [Reading UI State in Client](#reading-ui-state-in-client)

The UI state can be accessed in Client Components using the [`useUIState`](../reference/ai-sdk-rsc/use-ui-state.html) hook provided by the RSC API. The hook returns the current UI state and a function to update the UI state like React's `useState`.












``` tsx
'use client';
import  from '@ai-sdk/rsc';
export default function Page() ></li>      ))}    </ul>  );}
```


## [Reading AI State in Client](#reading-ai-state-in-client)

The AI state can be accessed in Client Components using the [`useAIState`](../reference/ai-sdk-rsc/use-ai-state.html) hook provided by the RSC API. The hook returns the current AI state.












``` tsx
'use client';
import  from '@ai-sdk/rsc';
export default function Page() ></li>      ))}    </ul>  );}
```


## [Reading AI State on Server](#reading-ai-state-on-server)

The AI State can be accessed within any Server Action provided to the `createAI` context using the [`getAIState`](../reference/ai-sdk-rsc/get-ai-state.html) function. It returns the current AI state as a read-only value:












``` tsx
import  from '@ai-sdk/rsc';
export async function sendMessage(message: string) ],  });
  return response;}
```





Remember, you can only access state within actions that have been passed to the `createAI` context within the `actions` key.



## [Updating AI State on Server](#updating-ai-state-on-server)

The AI State can also be updated from within your Server Action with the [`getMutableAIState`](../reference/ai-sdk-rsc/get-mutable-ai-state.html) function. This function is similar to `getAIState`, but it returns the state with methods to read and update it:












``` tsx
import  from '@ai-sdk/rsc';
export async function sendMessage(message: string) ]);
  const response = await generateText();
  // Update the AI state again with the response from the model.  history.done([...history.get(), ]);
  return response;}
```





It is important to update the AI State with new responses using `.update()` and `.done()` to keep the conversation history in sync.



## [Calling Server Actions from the Client](#calling-server-actions-from-the-client)

To call the `sendMessage` action from the client, you can use the [`useActions`](../reference/ai-sdk-rsc/use-actions.html) hook. The hook returns all the available Actions that were provided to `createAI`:












``` tsx
'use client';
import  from '@ai-sdk/rsc';import  from './ai';
export default function Page()  = useActions<typeof AI>();  const [messages, setMessages] = useUIState();
  const handleSubmit = async event => ,    ]);
    const response = await sendMessage(event.target.message.value);
    setMessages([      ...messages,      ,    ]);  };
  return (    <>      <ul>        ></li>        ))}      </ul>      <form onSubmit=>        <input type="text" name="message" />        <button type="submit">Send</button>      </form>    </>  );}
```


When the user submits a message, the `sendMessage` action is called with the message content. The response from the action is then added to the UI state, updating the displayed messages.




Important! Don't forget to update the UI State after you call your Server Action otherwise the streamed component will not show in the UI.



To learn more, check out this [example](generative-ui-state.html#what-is-ai-and-ui-state) on managing AI and UI state using `@ai-sdk/rsc`.

------------------------------------------------------------------------

Next, you will learn how you can save and restore state with `@ai-sdk/rsc`.
















On this page















































Vercel delivers the infrastructure and developer experience you need to ship reliable AI-powered applications at scale.

Trusted by industry leaders:















#### Resources




#### More




#### About Vercel




#### Legal







Â© 2025 Vercel, Inc.