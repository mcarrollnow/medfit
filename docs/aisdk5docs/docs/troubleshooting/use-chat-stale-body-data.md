AI SDK 5 is available now.










Menu




































































































































































































































































































































































































































































































# [Stale body values with useChat](#stale-body-values-with-usechat)

## [Issue](#issue)

When using `useChat` and passing dynamic information via the `body` parameter at the hook level, the data remains stale and only reflects the value from the initial component render. This occurs because the body configuration is captured once when the hook is initialized and doesn't update with subsequent component re-renders.



``` tsx
// Problematic code - body data will be staleexport default function Chat()  = useChat(,    }),  });
  // Even if temperature or userId change, the body in requests will still use initial values  return (    <div>      <input        type="range"        value=        onChange=      />          </div>  );}
```


## [Background](#background)

The hook-level body configuration is evaluated once during the initial render and doesn't re-evaluate when component state changes.

## [Solution](#solution)

Pass dynamic variables via the second argument of the `sendMessage` function instead of at the hook level. Request-level options are evaluated on each call and take precedence over hook-level options.



``` tsx
export default function Chat()  = useChat(),  });
  return (    <div>      <input        type="range"        value=        onChange=      />
      <form        onSubmit=,              ,              },            );            setInput('');          }        }}      >        <input value= onChange= />      </form>    </div>  );}
```


### [Alternative: Dynamic Hook-Level Configuration](#alternative-dynamic-hook-level-configuration)

If you need hook-level configuration that responds to changes, you can use functions that return configuration values. However, for component state, you'll need to use `useRef` to access current values:



``` tsx
export default function Chat()  = useChat(),    }),  });
  // ...}
```


**Recommendation:** Request-level configuration is simpler and more reliable for component state. Use it whenever you need to pass dynamic values that change during the component lifecycle.

### [Server-side handling](#server-side-handling)

On your server side, retrieve the custom fields by destructuring the request body:



``` tsx
// app/api/chat/route.tsexport async function POST(req: Request)  = await req.json();
  const result = streamText();
  return result.toUIMessageStreamResponse();}
```


For more information, see [chatbot request configuration documentation](../ai-sdk-ui/chatbot.html#request-configuration).
















On this page






























Vercel delivers the infrastructure and developer experience you need to ship reliable AI-powered applications at scale.

Trusted by industry leaders:















#### Resources




#### More




#### About Vercel




#### Legal







Â© 2025 Vercel, Inc.