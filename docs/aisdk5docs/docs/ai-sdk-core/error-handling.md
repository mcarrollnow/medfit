AI SDK 5 is available now.










Menu






















































































































































































































































































































































# [Error Handling](#error-handling)

## [Handling regular errors](#handling-regular-errors)

Regular errors are thrown and can be handled using the `try/catch` block.



``` ts
import  from 'ai';
try  = await generateText();} catch (error) 
```


See [Error Types](../reference/ai-sdk-errors.html) for more information on the different types of errors that may be thrown.

## [Handling streaming errors (simple streams)](#handling-streaming-errors-simple-streams)

When errors occur during streams that do not support error chunks, the error is thrown as a regular error. You can handle these errors using the `try/catch` block.



``` ts
import  from 'ai';
try  = streamText();
  for await (const textPart of textStream) } catch (error) 
```


## [Handling streaming errors (streaming with `error` support)](#handling-streaming-errors-streaming-with-error-support)

Full streams support error parts. You can handle those parts similar to other parts. It is recommended to also add a try-catch block for errors that happen outside of the streaming.



``` ts
import  from 'ai';
try  = streamText();
  for await (const part of fullStream) 
      case 'abort': 
      case 'tool-error':     }  }} catch (error) 
```


## [Handling stream aborts](#handling-stream-aborts)

When streams are aborted (e.g., via chat stop button), you may want to perform cleanup operations like updating stored messages in your UI. Use the `onAbort` callback to handle these cases.

The `onAbort` callback is called when a stream is aborted via `AbortSignal`, but `onFinish` is not called. This ensures you can still update your UI state appropriately.



``` ts
import  from 'ai';
const  = streamText() => ,  onFinish: () => ,});
for await (const textPart of textStream) 
```


The `onAbort` callback receives:

- `steps`: An array of all completed steps before the abort

You can also handle abort events directly in the stream:



``` ts
import  from 'ai';
const  = streamText();
for await (const chunk of fullStream)     // ... handle other part types  }}
```

















On this page

























Vercel delivers the infrastructure and developer experience you need to ship reliable AI-powered applications at scale.

Trusted by industry leaders:















#### Resources




#### More




#### About Vercel




#### Legal







Â© 2025 Vercel, Inc.