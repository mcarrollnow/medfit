AI SDK 5 is available now.










Menu


























































































































































































































































































































































































# [Markdown Chatbot with Memoization](#markdown-chatbot-with-memoization)

When building a chatbot with Next.js and the AI SDK, you'll likely want to render the model's responses in Markdown format using a library like `react-markdown`. However, this can have negative performance implications as the Markdown is re-rendered on each new token received from the streaming response.

As conversations get longer and more complex, this performance impact becomes exponentially worse since the entire conversation history is re-rendered with each new token.

This recipe uses memoization - a performance optimization technique where the results of expensive function calls are cached and reused to avoid unnecessary re-computation. In this case, parsed Markdown blocks are memoized to prevent them from being re-parsed and re-rendered on each token update, which means that once a block is fully parsed, it's cached and reused rather than being regenerated. This approach significantly improves rendering performance for long conversations by eliminating redundant parsing and rendering operations.

## [Installation](#installation)

First, install the required dependencies for Markdown rendering and parsing:



``` bash
npm install react-markdown marked
```


## [Server](#server)

On the server, you use a simple route handler that streams the response from the language model.












``` tsx
import  from '@ai-sdk/openai';import  from 'ai';
export async function POST(req: Request) :  = await req.json();
  const result = streamText();
  return result.toUIMessageStreamResponse();}
```


## [Memoized Markdown Component](#memoized-markdown-component)

Next, create a memoized markdown component that will take in raw Markdown text into blocks and only updates when the content actually changes. This component splits Markdown content into blocks using the `marked` library to identify discrete Markdown elements, then uses React's memoization features to optimize re-rendering by only updating blocks that have actually changed.












``` tsx
import  from 'marked';import  from 'react';import ReactMarkdown from 'react-markdown';
function parseMarkdownIntoBlocks(markdown: string): string[] 
const MemoizedMarkdownBlock = memo(  (: ) => </ReactMarkdown>;  },  (prevProps, nextProps) => ,);
MemoizedMarkdownBlock.displayName = 'MemoizedMarkdownBlock';
export const MemoizedMarkdown = memo(  (: ) =>  key=-block_$`} />    ));  },);
MemoizedMarkdown.displayName = 'MemoizedMarkdown';
```


## [Client](#client)

Finally, on the client, use the `useChat` hook to manage the chat state and render the chat interface. You can use the `MemoizedMarkdown` component to render the message contents in Markdown format without compromising on performance. Additionally, you can render the form in its own component so as to not trigger unnecessary re-renders of the chat messages. You can also use the `experimental_throttle` option that will throttle data updates to a specified interval, helping to manage rendering performance.












``` typescript
"use client";
import  from "@ai-sdk/react";import  from "ai";import  from "react";import  from "@/components/memoized-markdown";
const chat = new Chat(),});
export default function Page()  = useChat();
  return (    <div className="flex flex-col w-full max-w-xl py-24 mx-auto stretch">      <div className="space-y-8 mb-4">        >            <div className="font-bold mb-2">                          </div>            <div className="prose space-y-2">              -text`}                      id=                      content=                    />                  );                }              })}            </div>          </div>        ))}      </div>
      <MessageInput />    </div>  );}
const MessageInput = () =>  = useChat();
  return (    <form      onSubmit=);        setInput("");      }}    >      <input        className="fixed bottom-0 w-full max-w-xl p-2 mb-8 dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-800 rounded shadow-xl"        placeholder="Say something..."        value=        onChange=}      />    </form>  );};
```





The chat state is shared between both components by using the same `Chat` instance. This allows you to split the form and chat messages into separate components while maintaining synchronized state.


















On this page

























Vercel delivers the infrastructure and developer experience you need to ship reliable AI-powered applications at scale.

Trusted by industry leaders:















#### Resources




#### More




#### About Vercel




#### Legal







Â© 2025 Vercel, Inc.